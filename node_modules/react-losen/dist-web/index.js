import { Component } from 'react';
import PropTypes from 'prop-types';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

/*
  Function `findLastValidStepIndex()`
    Iterates over the n last steps (starting from nextStep index) and returns the last index
    where autoSkip property is not true.
*/
const findLastValidStepIndex = function findLastValidStepIndex(steps) {
  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let last = startIndex;
  steps.slice(startIndex).forEach((el, index) => {
    if (!el.autoSkip) {
      last = startIndex + index;
    }
  });
  return last;
};
const getSafeNext = (currentIndex, steps, direction) => {
  const numberOfSteps = steps.length;
  const nextStep = direction === 'previous' ? currentIndex - 1 : currentIndex + 1;

  if (nextStep < 0) {
    return 0;
  }

  const lastValidStep = findLastValidStepIndex(steps);

  if (lastValidStep < nextStep) {
    return lastValidStep;
  }

  if (nextStep >= numberOfSteps) {
    return numberOfSteps - 1;
  }

  return nextStep;
};

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
const emptyStep = {
  name: '',
  validator: () => '',
  autoSkip: null
};

class Wizard extends Component {
  constructor() {
    super(...arguments);

    _defineProperty$1(this, "state", {
      activeStep: emptyStep,
      activeStepIndex: 0,
      direction: null,
      isFirstStep: true,
      isLastStep: false,
      steps: [],
      stepData: {}
    });

    _defineProperty$1(this, "stateDebugger", () => {
      if (this.props.debug) {
        console.debug('WIZARD STATE UPDATED', this.state); // eslint-disable-line
      }
    });

    _defineProperty$1(this, "onPartialChange", name => data => {
      const newStepData = data !== 'undefined' ? {
        [name]: data
      } : {};
      this.setState(prevState => _objectSpread({}, prevState, {
        stepData: _objectSpread({}, prevState.stepData, newStepData)
      }), this.stateDebugger);
    });

    _defineProperty$1(this, "onComplete", () => {
      this.props.onComplete(this.state.stepData, this.state.activeStep.name);
    });
  }

  getChildContext() {
    return {
      activeStep: this.state.activeStep,
      isFirstStep: this.state.isFirstStep,
      isLastStep: this.state.isLastStep,

      /*
        Called in componentDidMount() lifecycle of Step.js
        It sets the FIRST_ELEMENT to make the wizard always start at the first registered Step element.
         Note: The first element to register is implicitly a start_step (as is the last one a finishing_step).
      */
      registerStep: (name, validateFunction, autoSkip) => {
        const FIRST_ELEMENT = 0;
        this.setState(prevState => _objectSpread({}, prevState, {
          activeStep: prevState.steps[FIRST_ELEMENT] || name,
          activeStepIndex: FIRST_ELEMENT,
          steps: [...prevState.steps, {
            name,
            validator: validateFunction,
            autoSkip
          }]
        }));
      },
      // This function finds and updates data in a given step in an immutable fashion
      updateStep: (name, updatedData) => {
        const stepIndex = this.state.steps.findIndex(el => el.name === name);
        this.setState(prevState => ({
          steps: [...prevState.steps.slice(0, stepIndex), _objectSpread({}, prevState.steps[stepIndex], updatedData), ...prevState.steps.slice(stepIndex + 1)]
        }));
      },

      /*
        Main usage: Used by Controls.js when clicking either next or previous button.
        Secondary: Called from Step.js if autoSkip prop is true. This is why we store the direction
         // TODO: Direction should probably be renamed. Can be of type <'' | 'next' | 'previous' | 'complete'>
      */
      changeStep: async newDirection => {
        const _this$state = this.state,
              activeStep = _this$state.activeStep,
              stepData = _this$state.stepData,
              steps = _this$state.steps,
              direction = _this$state.direction,
              activeStepIndex = _this$state.activeStepIndex;
        const onStepChange = this.props.onStepChange;

        try {
          if (newDirection === 'next' || newDirection === 'complete') {
            if (typeof activeStep.validator === 'function') {
              await activeStep.validator();
            }
          }

          if (newDirection === 'complete') {
            this.onComplete();
          } else {
            const _direction = newDirection || direction;

            const nextStep = getSafeNext(activeStepIndex, steps, _direction);
            const prevStepName = activeStep.name;
            const nextStepName = steps[nextStep].name;

            if (onStepChange && !steps[nextStep].autoSkip) {
              onStepChange({
                prevStepName,
                nextStepIndex: nextStep,
                nextStepName,
                numSteps: steps.length,
                stepData
              });
            }

            this.setState({
              activeStep: steps[nextStep] || emptyStep,
              activeStepIndex: nextStep,
              direction: _direction,
              isFirstStep: nextStep < 1,
              isLastStep: nextStep === findLastValidStepIndex(steps, nextStep)
            }, this.stateDebugger);
          }
        } catch (error) {
          if (this.props.onError) {
            this.props.onError(error);
          }
        }
      }
    };
  }

  render() {
    return this.props.render(this.state.stepData, this.onPartialChange);
  }

}

_defineProperty$1(Wizard, "defaultProps", {
  onStepChange: () => {},
  debug: false,
  onError: null
});

Wizard.childContextTypes = {
  activeStep: PropTypes.shape({
    name: PropTypes.string.isRequired,
    validator: PropTypes.func
  }).isRequired,
  changeStep: PropTypes.func.isRequired,
  isFirstStep: PropTypes.bool.isRequired,
  isLastStep: PropTypes.bool.isRequired,
  registerStep: PropTypes.func.isRequired,
  updateStep: PropTypes.func.isRequired
};

function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/*
 This component accepts a name acts as a context provider between Wizard and it's children.
 It register itself on mount and accepts a validator prop. This can be used by the wizard to 
 validate if it's cool to advance to the next step.
*/

class Step extends Component {
  constructor() {
    super(...arguments);

    _defineProperty$2(this, "context", void 0);
  }

  componentDidMount() {
    this.context.registerStep(this.props.name, this.props.validator, this.props.autoSkip);
  }

  componentWillReceiveProps(nextProps, nextContext) {
    if (nextContext.activeStep.name === this.props.name && this.props.autoSkip) {
      this.context.changeStep();
    }

    if (nextProps.autoSkip !== this.props.autoSkip) {
      // autoskip has changed. Lets notify the wizard
      this.context.updateStep(this.props.name, {
        autoSkip: nextProps.autoSkip
      });
    }
  }

  render() {
    if (this.context.activeStep.name === this.props.name) {
      return this.props.children;
    }

    return null;
  }

}

_defineProperty$2(Step, "defaultProps", {
  autoSkip: false,
  validator: null
});

Step.contextTypes = {
  activeStep: PropTypes.shape({
    name: PropTypes.string.isRequired,
    validator: PropTypes.func
  }).isRequired,
  changeStep: PropTypes.func.isRequired,
  registerStep: PropTypes.func.isRequired,
  updateStep: PropTypes.func.isRequired
};

function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class Controls extends Component {
  constructor() {
    super(...arguments);

    _defineProperty$3(this, "context", void 0);

    _defineProperty$3(this, "changeStep", direction => {
      this.context.changeStep(direction);
    });

    _defineProperty$3(this, "onNext", () => {
      if (this.context.isLastStep) {
        this.context.changeStep('complete');
      } else {
        this.context.changeStep('next');
      }
    });

    _defineProperty$3(this, "onPrevious", () => {
      if (!this.context.isFirstStep) {
        this.context.changeStep('previous');
      }
    });
  }

  render() {
    const _this$context = this.context,
          isFirstStep = _this$context.isFirstStep,
          isLastStep = _this$context.isLastStep;
    return this.props.render(this.onNext, this.onPrevious, isFirstStep, isLastStep);
  }

}

Controls.contextTypes = {
  changeStep: PropTypes.func.isRequired,
  isFirstStep: PropTypes.bool.isRequired,
  isLastStep: PropTypes.bool.isRequired
};

export { Wizard, Step, Controls };

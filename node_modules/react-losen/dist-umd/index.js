(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types'], factory) :
  (global = global || self, factory(global.reactLosen = {}, global.React, global.PropTypes));
}(this, function (exports, React, PropTypes) { 'use strict';

  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var _this = undefined;

  /*
    Function `findLastValidStepIndex()`
      Iterates over the n last steps (starting from nextStep index) and returns the last index
      where autoSkip property is not true.
  */
  var findLastValidStepIndex = function findLastValidStepIndex(steps) {
    var _this2 = this;

    var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _newArrowCheck(this, _this);

    var last = startIndex;
    steps.slice(startIndex).forEach(function (el, index) {
      _newArrowCheck(this, _this2);

      if (!el.autoSkip) {
        last = startIndex + index;
      }
    }.bind(this));
    return last;
  }.bind(undefined);
  var getSafeNext = function getSafeNext(currentIndex, steps, direction) {
    _newArrowCheck(this, _this);

    var numberOfSteps = steps.length;
    var nextStep = direction === 'previous' ? currentIndex - 1 : currentIndex + 1;

    if (nextStep < 0) {
      return 0;
    }

    var lastValidStep = findLastValidStepIndex(steps);

    if (lastValidStep < nextStep) {
      return lastValidStep;
    }

    if (nextStep >= numberOfSteps) {
      return numberOfSteps - 1;
    }

    return nextStep;
  }.bind(undefined);

  var _this$1 = undefined;

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  var emptyStep = {
    name: '',
    validator: function validator() {
      _newArrowCheck(this, _this$1);

      return '';
    }.bind(undefined),
    autoSkip: null
  };

  var Wizard =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Wizard, _Component);

    function Wizard() {
      var _getPrototypeOf2,
          _this3 = this;

      var _this2;

      _classCallCheck(this, Wizard);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this2 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Wizard)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty$1(_assertThisInitialized(_this2), "state", {
        activeStep: emptyStep,
        activeStepIndex: 0,
        direction: null,
        isFirstStep: true,
        isLastStep: false,
        steps: [],
        stepData: {}
      });

      _defineProperty$1(_assertThisInitialized(_this2), "stateDebugger", function () {
        _newArrowCheck(this, _this3);

        if (_this2.props.debug) {
          console.debug('WIZARD STATE UPDATED', _this2.state); // eslint-disable-line
        }
      }.bind(this));

      _defineProperty$1(_assertThisInitialized(_this2), "onPartialChange", function (name) {
        var _this4 = this;

        _newArrowCheck(this, _this3);

        return function (data) {
          var _this5 = this;

          _newArrowCheck(this, _this4);

          var newStepData = data !== 'undefined' ? _defineProperty({}, name, data) : {};

          _this2.setState(function (prevState) {
            _newArrowCheck(this, _this5);

            return _objectSpread({}, prevState, {
              stepData: _objectSpread({}, prevState.stepData, newStepData)
            });
          }.bind(this), _this2.stateDebugger);
        }.bind(this);
      }.bind(this));

      _defineProperty$1(_assertThisInitialized(_this2), "onComplete", function () {
        _newArrowCheck(this, _this3);

        _this2.props.onComplete(_this2.state.stepData, _this2.state.activeStep.name);
      }.bind(this));

      return _this2;
    }

    _createClass(Wizard, [{
      key: "getChildContext",
      value: function getChildContext() {
        var _this6 = this;

        return {
          activeStep: this.state.activeStep,
          isFirstStep: this.state.isFirstStep,
          isLastStep: this.state.isLastStep,

          /*
            Called in componentDidMount() lifecycle of Step.js
            It sets the FIRST_ELEMENT to make the wizard always start at the first registered Step element.
             Note: The first element to register is implicitly a start_step (as is the last one a finishing_step).
          */
          registerStep: function registerStep(name, validateFunction, autoSkip) {
            var _this7 = this;

            _newArrowCheck(this, _this6);

            var FIRST_ELEMENT = 0;
            this.setState(function (prevState) {
              _newArrowCheck(this, _this7);

              return _objectSpread({}, prevState, {
                activeStep: prevState.steps[FIRST_ELEMENT] || name,
                activeStepIndex: FIRST_ELEMENT,
                steps: [].concat(_toConsumableArray(prevState.steps), [{
                  name: name,
                  validator: validateFunction,
                  autoSkip: autoSkip
                }])
              });
            }.bind(this));
          }.bind(this),
          // This function finds and updates data in a given step in an immutable fashion
          updateStep: function updateStep(name, updatedData) {
            var _this8 = this;

            _newArrowCheck(this, _this6);

            var stepIndex = this.state.steps.findIndex(function (el) {
              _newArrowCheck(this, _this8);

              return el.name === name;
            }.bind(this));
            this.setState(function (prevState) {
              _newArrowCheck(this, _this8);

              return {
                steps: [].concat(_toConsumableArray(prevState.steps.slice(0, stepIndex)), [_objectSpread({}, prevState.steps[stepIndex], updatedData)], _toConsumableArray(prevState.steps.slice(stepIndex + 1)))
              };
            }.bind(this));
          }.bind(this),

          /*
            Main usage: Used by Controls.js when clicking either next or previous button.
            Secondary: Called from Step.js if autoSkip prop is true. This is why we store the direction
             // TODO: Direction should probably be renamed. Can be of type <'' | 'next' | 'previous' | 'complete'>
          */
          changeStep:
          /*#__PURE__*/
          function () {
            var _changeStep = _asyncToGenerator(
            /*#__PURE__*/
            regeneratorRuntime.mark(function _callee(newDirection) {
              var _this$state, activeStep, stepData, steps, direction, activeStepIndex, onStepChange, _direction, nextStep, prevStepName, nextStepName;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _newArrowCheck(this, _this6);

                      _this$state = this.state, activeStep = _this$state.activeStep, stepData = _this$state.stepData, steps = _this$state.steps, direction = _this$state.direction, activeStepIndex = _this$state.activeStepIndex;
                      onStepChange = this.props.onStepChange;
                      _context.prev = 3;

                      if (!(newDirection === 'next' || newDirection === 'complete')) {
                        _context.next = 8;
                        break;
                      }

                      if (!(typeof activeStep.validator === 'function')) {
                        _context.next = 8;
                        break;
                      }

                      _context.next = 8;
                      return activeStep.validator();

                    case 8:
                      if (newDirection === 'complete') {
                        this.onComplete();
                      } else {
                        _direction = newDirection || direction;
                        nextStep = getSafeNext(activeStepIndex, steps, _direction);
                        prevStepName = activeStep.name;
                        nextStepName = steps[nextStep].name;

                        if (onStepChange && !steps[nextStep].autoSkip) {
                          onStepChange({
                            prevStepName: prevStepName,
                            nextStepIndex: nextStep,
                            nextStepName: nextStepName,
                            numSteps: steps.length,
                            stepData: stepData
                          });
                        }

                        this.setState({
                          activeStep: steps[nextStep] || emptyStep,
                          activeStepIndex: nextStep,
                          direction: _direction,
                          isFirstStep: nextStep < 1,
                          isLastStep: nextStep === findLastValidStepIndex(steps, nextStep)
                        }, this.stateDebugger);
                      }

                      _context.next = 14;
                      break;

                    case 11:
                      _context.prev = 11;
                      _context.t0 = _context["catch"](3);

                      if (this.props.onError) {
                        this.props.onError(_context.t0);
                      }

                    case 14:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this, [[3, 11]]);
            }));

            function changeStep(_x) {
              return _changeStep.apply(this, arguments);
            }

            return changeStep;
          }().bind(this)
        };
      }
    }, {
      key: "render",
      value: function render() {
        return this.props.render(this.state.stepData, this.onPartialChange);
      }
    }]);

    return Wizard;
  }(React.Component);

  _defineProperty$1(Wizard, "defaultProps", {
    onStepChange: function onStepChange() {
      _newArrowCheck(this, _this$1);
    }.bind(undefined),
    debug: false,
    onError: null
  });

  Wizard.childContextTypes = {
    activeStep: PropTypes.shape({
      name: PropTypes.string.isRequired,
      validator: PropTypes.func
    }).isRequired,
    changeStep: PropTypes.func.isRequired,
    isFirstStep: PropTypes.bool.isRequired,
    isLastStep: PropTypes.bool.isRequired,
    registerStep: PropTypes.func.isRequired,
    updateStep: PropTypes.func.isRequired
  };

  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }
  /*
   This component accepts a name acts as a context provider between Wizard and it's children.
   It register itself on mount and accepts a validator prop. This can be used by the wizard to 
   validate if it's cool to advance to the next step.
  */

  var Step =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(Step, _React$Component);

    function Step() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Step);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Step)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty$2(_assertThisInitialized(_this), "context", void 0);

      return _this;
    }

    _createClass(Step, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.context.registerStep(this.props.name, this.props.validator, this.props.autoSkip);
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps, nextContext) {
        if (nextContext.activeStep.name === this.props.name && this.props.autoSkip) {
          this.context.changeStep();
        }

        if (nextProps.autoSkip !== this.props.autoSkip) {
          // autoskip has changed. Lets notify the wizard
          this.context.updateStep(this.props.name, {
            autoSkip: nextProps.autoSkip
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        if (this.context.activeStep.name === this.props.name) {
          return this.props.children;
        }

        return null;
      }
    }]);

    return Step;
  }(React.Component);

  _defineProperty$2(Step, "defaultProps", {
    autoSkip: false,
    validator: null
  });

  Step.contextTypes = {
    activeStep: PropTypes.shape({
      name: PropTypes.string.isRequired,
      validator: PropTypes.func
    }).isRequired,
    changeStep: PropTypes.func.isRequired,
    registerStep: PropTypes.func.isRequired,
    updateStep: PropTypes.func.isRequired
  };

  function _defineProperty$3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var Controls =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Controls, _Component);

    function Controls() {
      var _getPrototypeOf2,
          _this2 = this;

      var _this;

      _classCallCheck(this, Controls);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Controls)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty$3(_assertThisInitialized(_this), "context", void 0);

      _defineProperty$3(_assertThisInitialized(_this), "changeStep", function (direction) {
        _newArrowCheck(this, _this2);

        _this.context.changeStep(direction);
      }.bind(this));

      _defineProperty$3(_assertThisInitialized(_this), "onNext", function () {
        _newArrowCheck(this, _this2);

        if (_this.context.isLastStep) {
          _this.context.changeStep('complete');
        } else {
          _this.context.changeStep('next');
        }
      }.bind(this));

      _defineProperty$3(_assertThisInitialized(_this), "onPrevious", function () {
        _newArrowCheck(this, _this2);

        if (!_this.context.isFirstStep) {
          _this.context.changeStep('previous');
        }
      }.bind(this));

      return _this;
    }

    _createClass(Controls, [{
      key: "render",
      value: function render() {
        var _this$context = this.context,
            isFirstStep = _this$context.isFirstStep,
            isLastStep = _this$context.isLastStep;
        return this.props.render(this.onNext, this.onPrevious, isFirstStep, isLastStep);
      }
    }]);

    return Controls;
  }(React.Component);

  Controls.contextTypes = {
    changeStep: PropTypes.func.isRequired,
    isFirstStep: PropTypes.bool.isRequired,
    isLastStep: PropTypes.bool.isRequired
  };

  exports.Wizard = Wizard;
  exports.Step = Step;
  exports.Controls = Controls;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { Component } from 'react';
import PropTypes from 'prop-types';
import { getSafeNext, findLastValidStepIndex } from "./utils.js";
const emptyStep = {
  name: '',
  validator: () => '',
  autoSkip: null
};

class Wizard extends Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      activeStep: emptyStep,
      activeStepIndex: 0,
      direction: null,
      isFirstStep: true,
      isLastStep: false,
      steps: [],
      stepData: {}
    });

    _defineProperty(this, "stateDebugger", () => {
      if (this.props.debug) {
        console.debug('WIZARD STATE UPDATED', this.state); // eslint-disable-line
      }
    });

    _defineProperty(this, "onPartialChange", name => data => {
      const newStepData = data !== 'undefined' ? {
        [name]: data
      } : {};
      this.setState(prevState => ({ ...prevState,
        stepData: { ...prevState.stepData,
          ...newStepData
        }
      }), this.stateDebugger);
    });

    _defineProperty(this, "onComplete", () => {
      this.props.onComplete(this.state.stepData, this.state.activeStep.name);
    });
  }

  getChildContext() {
    return {
      activeStep: this.state.activeStep,
      isFirstStep: this.state.isFirstStep,
      isLastStep: this.state.isLastStep,

      /*
        Called in componentDidMount() lifecycle of Step.js
        It sets the FIRST_ELEMENT to make the wizard always start at the first registered Step element.
         Note: The first element to register is implicitly a start_step (as is the last one a finishing_step).
      */
      registerStep: (name, validateFunction, autoSkip) => {
        const FIRST_ELEMENT = 0;
        this.setState(prevState => ({ ...prevState,
          activeStep: prevState.steps[FIRST_ELEMENT] || name,
          activeStepIndex: FIRST_ELEMENT,
          steps: [...prevState.steps, {
            name,
            validator: validateFunction,
            autoSkip
          }]
        }));
      },
      // This function finds and updates data in a given step in an immutable fashion
      updateStep: (name, updatedData) => {
        const stepIndex = this.state.steps.findIndex(el => el.name === name);
        this.setState(prevState => ({
          steps: [...prevState.steps.slice(0, stepIndex), { ...prevState.steps[stepIndex],
            ...updatedData
          }, ...prevState.steps.slice(stepIndex + 1)]
        }));
      },

      /*
        Main usage: Used by Controls.js when clicking either next or previous button.
        Secondary: Called from Step.js if autoSkip prop is true. This is why we store the direction
         // TODO: Direction should probably be renamed. Can be of type <'' | 'next' | 'previous' | 'complete'>
      */
      changeStep: async newDirection => {
        const {
          activeStep,
          stepData,
          steps,
          direction,
          activeStepIndex
        } = this.state;
        const {
          onStepChange
        } = this.props;

        try {
          if (newDirection === 'next' || newDirection === 'complete') {
            if (typeof activeStep.validator === 'function') {
              await activeStep.validator();
            }
          }

          if (newDirection === 'complete') {
            this.onComplete();
          } else {
            const _direction = newDirection || direction;

            const nextStep = getSafeNext(activeStepIndex, steps, _direction);
            const prevStepName = activeStep.name;
            const nextStepName = steps[nextStep].name;

            if (onStepChange && !steps[nextStep].autoSkip) {
              onStepChange({
                prevStepName,
                nextStepIndex: nextStep,
                nextStepName,
                numSteps: steps.length,
                stepData
              });
            }

            this.setState({
              activeStep: steps[nextStep] || emptyStep,
              activeStepIndex: nextStep,
              direction: _direction,
              isFirstStep: nextStep < 1,
              isLastStep: nextStep === findLastValidStepIndex(steps, nextStep)
            }, this.stateDebugger);
          }
        } catch (error) {
          if (this.props.onError) {
            this.props.onError(error);
          }
        }
      }
    };
  }

  render() {
    return this.props.render(this.state.stepData, this.onPartialChange);
  }

}

_defineProperty(Wizard, "defaultProps", {
  onStepChange: () => {},
  debug: false,
  onError: null
});

Wizard.childContextTypes = {
  activeStep: PropTypes.shape({
    name: PropTypes.string.isRequired,
    validator: PropTypes.func
  }).isRequired,
  changeStep: PropTypes.func.isRequired,
  isFirstStep: PropTypes.bool.isRequired,
  isLastStep: PropTypes.bool.isRequired,
  registerStep: PropTypes.func.isRequired,
  updateStep: PropTypes.func.isRequired
};
export default Wizard;